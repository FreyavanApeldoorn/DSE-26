import sys
import os
import numpy as np

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))

from DetailedDesign.funny_inputs import funny_inputs
# from power import Power
from propulsion import Propulsion
from DetailedDesign.mission import Mission
from DetailedDesign.deployment import Deployment

class Thermal:
    '''
    The thermal class contains the thermal subsystem sizing. 
    '''

    def __init__(self, inputs: dict[str, float], hardware=None) -> None:
        self.inputs = inputs
        self.hardware = hardware
        
        # Power required for each phase
        self.power_required_VTOL = inputs["power_required_VTOL"]
        self.power_required_cruise = inputs["power_required_cruise"]
        self.power_required_hover = inputs["power_required_hover"]
        self.power_deployment = inputs["power_deploy"]
        self.power_required_winch = inputs["power_required_winch"]

        # Duration of each phase
        self.time_ascent = inputs["time_ascent"] 
        self.time_descent = inputs["time_descent"]
        self.time_cruise_max = inputs["time_cruise_max"]
        self.time_cruise_min = inputs["time_cruise_min"]
        self.time_scan = inputs["time_scan"] # time during hover without having the winch activated
        self.time_deploy = inputs["time_deploy"] # time during hover with having the winch activated
        self.time_uav = inputs["time_uav"] # total time for one uav trip from ascend to return to nest

        # Battery parameters
        self.n_battery = inputs["n_battery"]
        self.battery_capacity = inputs["battery_capacity"] # Ah
        self.battery_potential = inputs["battery_potential"] # V
        self.battery_resistance = inputs["battery_resistance"] # Ohm

        # Other
        self.winch_eff = inputs["winch_eff"] # fraction (i.e. "0.65" means that 1 - 0.65 = 0.35 of the winch power required will be heat)
        self.processor_heat_diss = inputs["processor_heat_diss"] # given from the specifications

        # Material specifications
        self.shell_thickness = inputs["shell_thickness"]
        self.shell_k = inputs["shell_k"]
        self.shell_eff_area = inputs["shell_eff_area"]

        self.insulation_thickness = inputs["insulation_thickness"]
        self.insulation_k = inputs["insulation_k"]
        self.include_insulation = inputs["include_insulation"]

        self.heat_coeff_ext = inputs["heat_coeff_ext"] 

    # ~~~ Intermediate Functions ~~~

    def compute_resistances(self) -> float:
        '''
        Compute total thermal resistance (K/W)
        '''
        R_material = self.shell_thickness / (self.shell_k * self.shell_eff_area)
        R_convection = 1.0 / (self.heat_coeff_ext * self.shell_eff_area)
        
        # Get R_insulation
        if self.include_insulation:
            R_insulation = (self.insulation_thickness / (self.insulation_k * self.shell_eff_area))
        else:
            R_insulation = 0.

        # Return total R 
        return R_material + R_insulation + R_convection

    def battery_heat_dissipated(self, power_required: float, time: float,) -> float:
        '''
        Return the heat dissipated during a specific phase by all batteries and the total heat energy from all batteries based on the power required and duration
        '''
        battery_current = power_required / (self.battery_potential * self.n_battery) # A, current per battery
        battery_heat = battery_current**2 * self.battery_resistance # W, heat dissipated per battery
        phase_battery_heat = battery_heat * self.n_battery # W, heat dissipated for all batteries combined
        phase_battery_q = phase_battery_heat * time # J, heat energy generated by all batteries combined
        
        return phase_battery_heat, phase_battery_q
    
    def winch_heat_dissipated(self):
        '''
        Return the heat dissipated and heat energy generated by the winch
        '''
        winch_heat = self.power_required_winch * (1 - self.winch_eff) # W
        winch_q = winch_heat * self.time_deploy # J

        return winch_heat, winch_q
    
    def processor_heat_dissipated(self, time: float,) -> float:
        '''
        Return the heat dissipated and heat energy generated by the processor
        '''
        return self.processor_heat_diss, (self.processor_heat_diss * time)
    
    def phase_heat_dissipated(self, power_required: float, time: float,) -> float:
        '''
        Return the total heat dissipated and total heat energy generated

        -> !!! Note !!! This is not correct for the deployment phase as it ONLY includes the processor and battery
        -> !!! Note !!! The correct deployment phase heat is computed in 'create_heat_dissipated', where the winch heat is added
        '''
        phase_batt_heat, phase_batt_q = self.battery_heat_dissipated(power_required, time)
        phase_processor_heat, phase_processor_q = self.processor_heat_dissipated(time)

        # Not complete for deployment phase
        phase_heat_dissipated, phase_q = (phase_batt_heat + phase_processor_heat), (phase_batt_q + phase_processor_q)

        return phase_heat_dissipated, phase_q
    
    def create_heat_dissipated(self):
        '''
        Create a dictionary containing all the significant heat contributions per phase from both within the fuselage as well as due to external conditions
        '''
        all_heat = {}

        all_heat['ascend'] = {}

        all_heat['ascend']['batt_heat'], all_heat['ascend']['batt_q'] = self.battery_heat_dissipated(self.power_required_VTOL, self.time_ascent)
        all_heat['ascend']['processor_heat'], all_heat['ascend']['processor_q'] = self.processor_heat_dissipated(self.time_ascent)
        all_heat['ascend']['phase_heat'], all_heat['ascend']['phase_q'] = self.phase_heat_dissipated(self.power_required_VTOL, self.time_ascent)

        all_heat['descend'] = {}

        all_heat['descend']['batt_heat'], all_heat['descend']['batt_q'] = self.battery_heat_dissipated(self.power_required_VTOL, self.time_descent)
        all_heat['descend']['processor_heat'], all_heat['descend']['processor_q'] = self.processor_heat_dissipated(self.time_descent)
        all_heat['descend']['phase_heat'], all_heat['descend']['phase_q'] = self.phase_heat_dissipated(self.power_required_VTOL, self.time_descent)

        all_heat['cruise_max'] = {}

        all_heat['cruise_max']['batt_heat'], all_heat['cruise_max']['batt_q'] = self.battery_heat_dissipated(self.power_required_cruise, self.time_cruise_max)
        all_heat['cruise_max']['processor_heat'], all_heat['cruise_max']['processor_q'] = self.processor_heat_dissipated(self.time_cruise_max)
        all_heat['cruise_max']['phase_heat'], all_heat['cruise_max']['phase_q'] = self.phase_heat_dissipated(self.power_required_cruise, self.time_cruise_max)

        all_heat['cruise_min'] = {}

        all_heat['cruise_min']['batt_heat'], all_heat['cruise_min']['batt_q'] = self.battery_heat_dissipated(self.power_required_cruise, self.time_cruise_min)
        all_heat['cruise_min']['processor_heat'], all_heat['cruise_min']['processor_q'] = self.processor_heat_dissipated(self.time_cruise_min)
        all_heat['cruise_min']['phase_heat'], all_heat['cruise_min']['phase_q'] = self.phase_heat_dissipated(self.power_required_cruise, self.time_cruise_min)

        all_heat['scan'] = {}

        all_heat['scan']['batt_heat'], all_heat['scan']['batt_q'] = self.battery_heat_dissipated(self.power_required_hover, self.time_scan)
        all_heat['scan']['processor_heat'], all_heat['scan']['processor_q'] = self.processor_heat_dissipated(self.time_scan)
        all_heat['scan']['phase_heat'], all_heat['scan']['phase_q'] = self.phase_heat_dissipated(self.power_required_hover, self.time_scan)

        all_heat['deploy'] = {}

        all_heat['deploy']['batt_heat'], all_heat['deploy']['batt_q'] = self.battery_heat_dissipated(self.power_required_hover, self.time_deploy)
        all_heat['deploy']['processor_heat'], all_heat['deploy']['processor_q'] = self.processor_heat_dissipated(self.time_deploy)
        all_heat['deploy']['winch_heat'], all_heat['deploy']['winch_q'] = self.winch_heat_dissipated()
        all_heat['deploy']['phase_heat'], all_heat['deploy']['phase_q'] = (self.phase_heat_dissipated(self.power_required_hover, self.time_deploy)[0] + self.winch_heat_dissipated()[0]), (self.phase_heat_dissipated(self.power_required_hover, self.time_deploy)[1] + self.winch_heat_dissipated()[1])

        return all_heat
    
    def total_heat_storage(self):
        '''
        Compute the heat dissipated and heat energy generated during the hover + deployment phase in the "hot" zone.
        In the "hot" zone, it is not possible to dissipate heat using the heat sink, hence all this heat needs to be stored in the PCM.

        hover + deployment phase consists out of: scan > descend > deploy > ascend
        '''
        all_heat = self.create_heat_dissipated()
        
        total_heat_store = all_heat['scan']['phase_heat'] + all_heat['descend']['phase_heat'] + all_heat['deploy']['phase_heat'] + all_heat['ascend']['phase_heat']
        total_q_store = all_heat['scan']['phase_q'] + all_heat['descend']['phase_q'] + all_heat['deploy']['phase_q'] + all_heat['ascend']['phase_q']

        return total_heat_store, total_q_store
    
    def total_heat_approach_min(self):
        '''
        Compute the heat dissipated and heat energy generated during the shortest approach.
        All this heat has to be dissipated through the heat sink in this phase.
        
        Min. approach phase consists out of: ascend > cruise
        '''
        all_heat = self.create_heat_dissipated()
 
        total_heat_approach_min = all_heat['ascend']['phase_heat'] + all_heat['cruise_min']['phase_heat']
        total_q_approach_min = all_heat['ascend']['phase_q'] + all_heat['cruise_min']['phase_q']

        return total_heat_approach_min, total_q_approach_min
    
    def total_heat_return_min(self):
        '''
        Compute the heat dissipated and heat energy generated during the shortest return.
        All this heat + the excess from the "hot" has to be dissipated through the heat sink in this phase.
        
        Min. return phase consists out of: cruise > descend
        '''

        all_heat = self.create_heat_dissipated()
 
        total_heat_return_min = all_heat['cruise_min']['phase_heat'] + all_heat['descend']['phase_heat']
        total_q_return_min = all_heat['cruise_min']['phase_q'] + all_heat['descend']['phase_q']

        return total_heat_return_min, total_q_return_min




    # ~~~ Output functions ~~~ 

    # def get_all(self) -> dict[str, float]:
    #     '''
    #     Outputs:
        
    #     '''
    #     return outputs


if __name__ == '__main__':

    prop = Propulsion(funny_inputs)
    funny_inputs = prop.get_all()

    # power = Power(funny_inputs)
    # funny_inputs = power.get_all()

    mission = Mission(funny_inputs)
    funny_inputs = mission.get_all()

    deployment = Deployment(funny_inputs, strategy='perimeter', amt=funny_inputs['mission_perimeter'])
    funny_inputs = deployment.get_all()

    thermal = Thermal(funny_inputs)
    # outputs = thermal.get_all() 

    ther = Thermal(funny_inputs)

    # print('Dict/ total:', ther.create_heat_dissipated()['deploy'])
    # print('\n Winch', ther.winch_heat_dissipated())
    print(ther.total_heat_storage())