import sys
import os
import numpy as np

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))

from DetailedDesign.funny_inputs import funny_inputs
# from power import Power
from propulsion import Propulsion
from mission import Mission
from deployment import Deployment

class Thermal:
    '''
    The thermal class contains the thermal subsystem sizing. 
    '''

    def __init__(self, inputs: dict[str, float], hardware=None) -> None:
        self.inputs = inputs
        self.hardware = hardware
        
        # Power required for each phase
        self.power_required_VTOL = inputs["power_required_VTOL"]
        self.power_required_cruise = inputs["power_required_cruise"]
        self.power_required_hover = inputs["power_required_hover"]
        self.power_deployment = inputs["power_deploy"]

        # Duration of each phase
        self.time_ascent = inputs["time_ascent"] 
        self.time_descent = inputs["time_descent"]
        self.time_cruise_max = inputs["time_cruise_max"]
        self.time_cruise_min = inputs["time_cruise_min"]
        self.time_scan = inputs["time_scan"] # time during hover without having the winch activated
        self.time_deploy = inputs["time_deploy"] # time during hover with having the winch activated
        self.time_uav = inputs["time_uav"] # total time for one uav trip from ascend to return to nest

        # Battery parameters
        self.n_battery = inputs["n_battery"]
        self.battery_capacity = inputs["battery_capacity"]
        self.battery_potential = inputs["battery_potential"]
        self.battery_resistance = inputs["battery_resistance"]

        # Other
        self.power_required_winch = inputs["power_required_winch"]
        self.winch_eff = inputs["winch_eff"]
        self.processor_heat_dissipated = inputs["processor_heat_dissipated"]

    # ~~~ Intermediate Functions ~~~

    def battery_heat_dissipated(self, power_required: float, time: float,) -> float:
        '''
        Returns the heat dissipated by all batteries and the total heat energy from all batteries based on the power required and duration of a certain phase
        '''
        battery_current = power_required / (self.battery_potential * self.n_battery) # A, current per battery
        battery_heat = battery_current**2 * self.battery_resistance # W, heat dissipated per battery
        total_battery_heat = battery_heat * self.n_battery # W, heat dissipated for all batteries combined
        total_battery_q = total_battery_heat * time # J, heat energy generated by all batteries combined
        
        return total_battery_heat, total_battery_q
    
    def create_batt_heat_dissipated(self):
        '''
        Creates a dictionary with both the heat power and energy generated by all batteries combined per phase of flight

        Outputs:
        > batt_xxx_heat: heat dissipated power in W by all batteries combined
        > batt_xxx_q: total heat energy generated in J by all batteries combined during that phase, this will later be used to assess how much energy the PCM will need to be able to store
        '''

        # Initiate dictionary containing both power heat dissipated and heat energy
        batt_heat_dict = {}

        # Compute power heat dissipated by the battery and heat energy from the battery for each phase
        batt_ascend_heat, batt_ascend_q = self.battery_heat_dissipated(self.power_required_VTOL, self.time_ascent) # Each in W, J
        batt_descend_heat, batt_descend_q = self.battery_heat_dissipated(self.power_required_VTOL, self.time_descent)
        batt_cruise_max_heat, batt_cruise_max_q = self.battery_heat_dissipated(self.power_required_cruise, self.time_cruise_max)
        batt_cruise_min_heat, batt_cruise_min_q = self.battery_heat_dissipated(self.power_required_cruise, self.time_cruise_min)
        batt_scan_heat, batt_scan_q = self.battery_heat_dissipated(self.power_required_hover, self.time_scan)
        batt_deploy_heat, batt_deploy_q = self.battery_heat_dissipated((self.power_required_hover + self.power_deployment), self.time_deploy) # Both the power required to sustain hovering and the power needed to use the winch
        
        # Append previous values to the dictionary
        batt_heat_dict['ascend'] = batt_ascend_heat, batt_ascend_q # Each in W, J
        batt_heat_dict['descend'] = batt_descend_heat, batt_descend_q
        batt_heat_dict['cruise_max'] = batt_cruise_max_heat, batt_cruise_max_q
        batt_heat_dict['cruise_min'] = batt_cruise_min_heat, batt_cruise_min_q
        batt_heat_dict['scan'] = batt_scan_heat, batt_scan_q
        batt_heat_dict['deploy'] = batt_deploy_heat, batt_deploy_q

        return batt_heat_dict
    
    def winch_heat_dissipated(self):

        # Compute the heat dissipated and heat energy generated by the winch
        winch_heat = self.power_required_winch * (1 - self.winch_eff) # W
        winch_q = winch_heat * self.time_deploy # J

        return winch_heat, winch_q
    
    def create_processor_heat_dissipated(self):
        # Initiate dictionary containing both power heat dissipated and heat energy
        processor_heat_dict = {}

        # Compute heat energy from the processor for each phase
        processor_ascend_q = (self.processor_heat_dissipated * self.time_ascent) # Each in J
        processor_descend_q = (self.processor_heat_dissipated * self.time_descent)
        processor_cruise_max_q = (self.processor_heat_dissipated * self.time_cruise_max)
        processor_cruise_min_q = (self.processor_heat_dissipated * self.time_cruise_min)
        processor_scan_q = (self.processor_heat_dissipated * self.time_scan)
        processor_deploy_q = (self.processor_heat_dissipated * self.time_deploy) 
        
        # Append previous values to the dictionary
        processor_heat_dict['ascend'] = processor_ascend_q # Each in J
        processor_heat_dict['descend'] = processor_descend_q
        processor_heat_dict['cruise_max'] = processor_cruise_max_q
        processor_heat_dict['cruise_min'] = processor_cruise_min_q
        processor_heat_dict['scan'] = processor_scan_q
        processor_heat_dict['deploy'] = processor_deploy_q

        return processor_heat_dict
    


    # ~~~ Output functions ~~~ 

    def get_all(self) -> dict[str, float]:
        '''
        Outputs:
        
        '''
        return outputs


if __name__ == '__main__':

    prop = Propulsion(funny_inputs)
    funny_inputs = prop.get_all()

    # power = Power(funny_inputs)
    # funny_inputs = power.get_all()

    mission = Mission(funny_inputs)
    funny_inputs = mission.get_all()

    deployment = Deployment(funny_inputs)
    funny_inputs = deployment.get_all()

    thermal = Thermal(funny_inputs)
    outputs = thermal.get_all() 